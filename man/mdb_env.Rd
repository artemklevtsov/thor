% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mdb_env.R
\name{mdb_env}
\alias{mdb_env}
\title{Create an mdb_env environment}
\usage{
mdb_env(path, mode = as.octmode("644"), subdir = TRUE, rdonly = FALSE,
  metasync = TRUE, sync = TRUE, writemap = FALSE, lock = TRUE,
  mapasync = FALSE, rdahead = TRUE, meminit = TRUE, maxdbs = NULL,
  maxreaders = NULL, mapsize = NULL, reversekey = FALSE,
  dupsort = FALSE, create = TRUE)
}
\arguments{
\item{path}{The directory in which the database files will reside.
If \code{create} is \code{TRUE} this path will be created for
you if it does not exist (in contrast with the \code{lmdb} C
API).  If \code{subdir} is \code{FALSE} this is the path to the
database file and an additional lock file will be created by
appending "-lock" to \code{path}.}

\item{mode}{The file mode (UNIX file permissions) to set on
created files.  this must be an \code{octmode} object, with the
default (\code{as.octmode("644"}) being user-writable and
world-readable.}

\item{subdir}{By default, lmdb creates its files wthin a directory
(at \code{path}).  If \code{subdir = FALSE} then the \code{path}
is interpreted as the path to the main database file and a lock
file will be created with "-lock" appended to the filename.
Passing \code{subdir = FALSE} is equivalent to lmdb's
\code{MDB_NOSUBDIR} flag.}

\item{rdonly}{Open the environment in read-only mode.  No write
operations are allowed.  LMDB will still modify the lock file.
Passing \code{rdonly = TRUE} is equivalent to lmdb's
\code{MDB_RDONLY} flag.}

\item{metasync}{If \code{FALSE}, flush system buffers to disk only
once per transaction, omit the metadata flush. Defer that until
the system flushes files to disk, or next commit or the next
call to the \code{$sync()} method.  This optimization maintains
database integrity, but a system crash may undo the last
committed transaction. I.e. it preserves the ACI (atomicity,
consistency, isolation) but not D (durability) database
property.  Passing \code{metasync = FALSE} is equivalent to
lmdb's \code{MDB_NOMETASYNC} flag.}

\item{sync}{If \code{FALSE}, don't flush system buffers to disk
when committing a transaction.  This optimization means a system
crash can corrupt the database or lose the last transactions if
buffers are not yet flushed to disk.  The risk is governed by
how often the system flushes dirty buffers to disk and how often
the \code{$sync()} method is called.  However, if the filesystem
preserves write order and \code{writemap = FALSE}, transactions
exhibit ACI (atomicity, consistency, isolation) properties and
only lose D (durability).  I.e. database integrity is
maintained, but a system crash may undo the final transactions.
Note that \code{sync = FALSE, writemap = TRUE} leaves the system
with no hint for when to write transactions to disk, unless
\code{$sync()} is called.  \code{map_async = TRUE, writemap =
TRUE} may be preferable.  Passing \code{sync = FALSE} is
equivalent to lmdb's \code{MDB_NOSYNC} flag.}

\item{writemap}{If \code{TRUE}, use a writeable memory map unless
\code{rdonly = TRUE} is set. This uses fewer mallocs but loses
protection from application bugs like wild pointer writes and
other bad updates into the database. This may be slightly faster
for DBs that fit entirely in RAM, but is slower for DBs larger
than RAM. Incompatible with nested transactions. Do not mix
processes with \code{writemap = TRUE} and \code{writemap =
FALSE} on the same environment.  This can defeat durability
(\code{$sync()} etc).  Passing \code{writemap = TRUE} is
equivalent to lmdb's \code{MDB_WRITEMAP} flag.}

\item{lock}{If \code{FALSE}, don't do any locking. If concurrent
access is anticipated, the caller must manage all concurrency
itself. For proper operation the caller must enforce
single-writer semantics, and must ensure that no readers are
using old transactions while a writer is active. The simplest
approach is to use an exclusive lock so that no readers may be
active at all when a writer begins.  Passing \code{lock = FALSE}
is equivalent to lmdb's \code{MDB_NOLOCK} flag.}

\item{mapasync}{If \code{TRUE}, When using \code{writemap = TRUE},
use asynchronous flushes to disk.  As with \code{sync = FALSE},
a system crash can then corrupt the database or lose the last
transactions. Calling \code{$sync()} ensures on-disk database
integrity until next commit.  Passing \code{mapasync = FALSE} is
equivalent to lmdb's \code{MDB_MAPASYNC} flag.}

\item{rdahead}{If \code{FALSE}, turn off readahead. Most operating
systems perform readahead on read requests by default. This
option turns it off if the OS supports it. Turning it off may
help random read performance when the DB is larger than RAM and
system RAM is full.  \code{rdahead = FALSE} is not implemented
on Windows.  Passing \code{rdahead = FALSE} is equivalent to
lmdb's \code{MDB_NORDAHEAD} flag.}

\item{meminit}{If \code{FALSE}, don't initialize malloc'd memory
before writing to unused spaces in the data file. By default,
memory for pages written to the data file is obtained using
malloc. While these pages may be reused in subsequent
transactions, freshly malloc'd pages will be initialized to
zeroes before use. This avoids persisting leftover data from
other code (that used the heap and subsequently freed the
memory) into the data file. Note that many other system
libraries may allocate and free memory from the heap for
arbitrary uses. E.g., stdio may use the heap for file I/O
buffers. This initialization step has a modest performance cost
so some applications may want to disable it using this
flag. This option can be a problem for applications which handle
sensitive data like passwords, and it makes memory checkers like
Valgrind noisy. This flag is not needed with \code{writemap =
TRUE}, which writes directly to the mmap instead of using malloc
for pages.  Passing \code{meminit = FALSE} is equivalent to
lmdb's \code{MDB_NOMEMINIT}.}

\item{maxdbs}{The number of databases available within the
environment.  If 0 (the default), then the environment holds
just one database (the main dbb).  To use named databases this
must be set greater than one.}

\item{maxreaders}{Maximum number of simultaneous read
transactions.  Can only be set in the first process to open an
environment.}

\item{mapsize}{Maximum size database may grow to; used to size the
memory mapping.  If database grows larger than ``map_size``, an
error will be thrown and the user must close and reopen the
\code{mdb_env}.  On 64-bit there is no penalty for making this
huge (say 1TB). Must be <2GB on 32-bit.}

\item{reversekey}{Passed through to \code{open_database} for the
main database.  If \code{TRUE}, keys are strings to be compared
in reverse order, from the end of the strings to the beginning
(e.g., DNS names). By default, keys are treated as strings and
compared from beginning to end.  Passing \code{reversekey = TRUE}
is equivalent to lmdb's \code{MDB_REVERSEKEY}.}

\item{dupsort}{Passed through to \code{open_database} for the main
database.  If \code{TRUE}, duplicate keys may be used in the
database. (Or, from another perspective, keys may have multiple
data items, stored in sorted order.) By default keys must be
unique and may have only a single data item.  Passing
\code{dupsort = TRUE} is equivalent to lmdb's
\code{MDB_DUPSORT}.}

\item{create}{If \code{FALSE}, do not create the directory
\code{path} if it is missing.}
}
\description{
Create a \code{mdb_env} "environment" object.  This is the way
that interacts with a lmdb database and once created, includes
methods for querying the environment, creating databases, starting
transactions and (through those) adding, getting and removing
data.  This page includes \emph{reference} documentation for the
object and readers are first directed to the vignette
(\code{vignette("thor"}).
}
\details{
The \code{thor} package is a wrapper around \code{lmdb} and so
below I have provided pointers to relevant options in \code{lmdb}
- the wrapper is fairly thin and so picks up limitations and
restrictions from the underlying library.  Some portions of the
documentation here derives from the lmdb source documentation -
the file lmdb.h in particular.
}
\examples{
# Create a new environment (just using defaults)
env <- thor::mdb_env(tempfile())

# At its most simple (using temporary transactions)
env$put("a", "hello world")
env$get("a")

# Or create transactions
txn <- env$begin(write = TRUE)
txn$put("b", "another")
txn$put("c", "value")

# Transaction not committed so value not visible outside our transaction
env$get("b", missing_is_error = FALSE)

# After committing, the values are visible for new transactions
txn$commit()
env$get("b", missing_is_error = FALSE)
}
